"""
v0.4.0
December 22 2025
Author: Levi Malmström
"""

using Pkg
#Pkg.add("CUDA")
using CUDA
#Pkg.add("StaticArrays")
using StaticArrays

include("integrators_5P.jl")
include("tests_5P.jl")

#CONSTANTS
#Planck Constant in J/Hz
const h = Float32(6.62607015e-34)
#Reduced Planck Constant in J*s
const ħ = Float32(h/(2*pi))
#Speed of light in m/s
const c = Int32(299792458)
# π ∈ Irrational doesn't play well with CUDA.jl, so we'll just set it to be type Float32.
const π = Float32(π)
#Boltzman Constant in J/K
const k_B = Float32(1.380649e-23)
#How many meters corespond to one unit of the map
const map_scale = Float32(1)
#Protects from dividing by zero in certain situations
const no_div_zero = Float32(1e-24)
#Color match function fit values
const cie_matrix=[
[0.362 1.056 -0.065 0.821 0.286 1.217 0.681];
[442.0 599.8 501.1 568.8 530.9 437.0 459.0];
[0.0624 0.0264 0.0490 0.0213 0.0613 0.0845 0.0385];
[0.0374 0.0323 0.0382 0.0247 0.0322 0.0278 0.0725]]
#Dormand-Prince Butcher table
const DP_Butcher= Array{Float32}([
[0 0 0 0 0 0 0 0];
[1/5 1/5 0 0 0 0 0 0];
[3/10 3/40 9/40 0 0 0 0 0];
[4/5 44/45 -56/15 32/9 0 0 0 0];
[8/9 19372/6561 -25360/2187 64448/6561 -212/729 0 0 0];
[1 9017/3168 -355/33 46732/5247 49/176 -5103/18656 0 0];
[1 35/384 0 500/1113 125/192 -2187/6784 11/84 0];
[0 35/384 0 500/1113 125/192 -2187/6784 11/84 0];
[0 5179/57600 0 7571/16695 393/640 -92097/339200 187/2100 1/40]])


#println(CUDA.versioninfo())

"""
Runs the integration loop for a single pixel.
"""
function integrate_ray(ray,starting_timestep,colors,colors_freq,raylength,abs_tol,rel_tol,max_dt_scale,
                    max_steps) where raylength
    #integrate ray
    for i in 1:raylength
        ray[i] += 1
    end
    return ray
end



function ray_kernel!(long_ray_matrix,colors,colors_freq,
                     ::Val{raylength},abs_tol,rel_tol,max_dt_scale,max_steps,num_pix) where raylength
    
    index = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    stride = gridDim().x * blockDim().x
    for i = index:stride:length(long_ray_matrix)
        ray = @MVector zeros(Float32,raylength)

        for j in 1:raylength
            ray[j] = long_ray_matrix[i,j]
        end

        starting_timestep = -pad_max_dt(ray[1:8],max_dt_scale)
        ray = integrate_ray(ray,starting_timestep,colors,colors_freq,raylength,raylength,abs_tol,rel_tol,max_dt_scale,
                            max_steps)

        for j in 1:raylength
            long_ray_matrix[i,j] = ray[j]
        end

    end
    return nothing
end



"""
    gen_image(;camera_pos=[0,0,0,0],camera_dir=[0.0,0.0],speed=0.0::Real,
                        camera_point=[0.0,0.0,0.0],x_pix=40,max_steps=1e3,colors=[400,550,700],
                             returnrays=false,tolerance=1e-4::Real,max_dt_scale=1e-2::Real,fov_hor=85::Real,
                   fov_vert=60::Real)
Generates an image. Multithreaded.
# Arguments
- 'camera_pos': the 4-position of the camera
- 'camera_dir': two angles determining the direction of the camera's 3-velocity relative to the tetrad/FIDO.
- 'speed': the magnitude of the camera's 3-velocity relative to the tetrad/FIDO in units of c.
- 'camera_point': the orientation of the camera relative to it's velocity vector.
- 'x_pix': the size of the bottom of the image, in pixels.
- 'max_steps': the maximum number of timesteps to integrate.
- 'colors': the wavelengths of frequencies to use in the spectrum, in nm.
- 'returnrays': return the rays which were traced.
- 'tolerance': number I'm currently using to set the error tolerance of the integrator.
- 'max_dt_scale': a positive number characterising the maximum size of timesteps. Decrease to shrink the timestep size.
- 'fov_hor': horizontal field of view, in degrees.
- 'fov_vert': vertical field of view, in degrees.
"""
function gen_image(;camera_pos=[0,0,0,0],camera_dir=[0.0,0.0],speed=0.0::Real,
                        camera_point=[0.0,0.0,0.0],x_pix=40,max_steps=1e3,colors=[400,550,700],
                             returnrays=false,tolerance=1e-4::Real,max_dt_scale=1e-2::Real,fov_hor=85::Real,
                   fov_vert=60::Real)
    #check that camera is in a valid location
    if is_singularity(camera_pos)
        println("Invalid Camera; returning blank image")
        return zeros(RGB{N0f16},2)
    end

    #initialize rays
    ray_matrix = initialize_camera(camera_pos,direction=camera_dir,β=speed,pointing=camera_point,
                                   horizontal_pixels=x_pix,colors=colors,fov_hor=fov_hor, fov_vert=fov_vert)
    println(ray_matrix[1,1,:])
    y_pix=size(ray_matrix,2)
    num_pix=x_pix*y_pix
    println("num_pix= ",num_pix)

    n_colors=length(colors)
    raylength = 8+2*n_colors
    long_ray_matrix = reshape(ray_matrix,(num_pix,raylength))
    ray_matrix_shape = size(ray_matrix)
    
    #initialize xyY pixels
    xyY_img=zeros(xyY{Float64},x_pix,ray_matrix_shape[2])
    

    f(x)=c*1e9/x

    #initialize colors_freq
    colors_freq = f.(colors)

    #make tolerance arrays
    abs_tol=fill(tolerance,raylength)
    rel_tol=fill(tolerance,raylength)



    #transfer/transfrom data to GPU
    Cu_ray_matrix = CuArray{Float32}(long_ray_matrix)
    Cu_colors = CuArray{Float32}(colors)
    Cu_colors_freq = CuArray{Float32}(colors_freq)
    Cu_abs_tol = CuArray{Float32}(abs_tol)
    Cu_rel_tol = CuArray{Float32}(rel_tol)
    
    #compile the kernel and make the configuration
    Cu_ray_kernel = @cuda launch=false ray_kernel!(Cu_ray_matrix,Cu_colors,Cu_colors_freq,
                                                   Val(raylength),Cu_abs_tol,Cu_rel_tol,Float32(max_dt_scale),
                                                   Int32(max_steps),Int32(num_pix))
    config = launch_configuration(Cu_ray_kernel.fun)
    threads = min(num_pix,config.threads)
    blocks = cld(num_pix,threads)
    println("Threads: ", threads)
    println("Blocks: ", blocks)

    CUDA.@sync begin
        Cu_ray_kernel(Cu_ray_matrix,Cu_colors,Cu_colors_freq,
                      Val(raylength),Cu_abs_tol,Cu_rel_tol,Float32(max_dt_scale),
                      Int32(max_steps),Int32(num_pix))
    end
    
    long_ray_matrix = Array(Cu_ray_matrix)
    ray_matrix = reshape(long_ray_matrix,(x_pix,y_pix,raylength))
    println(ray_matrix[1,1,:])
end
