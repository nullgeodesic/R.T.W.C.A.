"""
v0.3.2
October 3 2025
Author: Levi MalmstrÃ¶m
"""
function calc_ray_derivative(Ray,raylength,colors_freq)
    #calculate derivative at a point
    slope= zeros(raylength)
    for i in 1:4
        #dx/dl=v
        slope[i]=Ray[i+4]
    end
    for i in 5:8
        #geodesic equation
        a=0
        for j in 5:8
            for k in 5:8
                a=a - calc_christoffel_udd(Ray[1:4],CartesianIndex(i-4,j-4,k-4))*Ray[j]*Ray[k]
            end
        end
        slope[i]=a
    end
    for i in 9:raylength
        if isodd(i)
            #calculate the frequency of the ray in the source frame, by nu=E/hbar, E = -p * u
            freq_shift=-transpose(get_source_velocity(Ray[1:4]))*calc_lower_metric(Ray[1:4])*Ray[5:8]
            nu=colors_freq[ceil(Int,(i-8)/2)]*freq_shift
            #derivative of the invariant brightness the ray "will" (hence the - sign) gain between here and the camera
            slope[i]=-calc_spectral_emission_coeficient(Ray[1:8],nu)*exp(-Ray[i+1])/nu^3
        else
            #calculate the frequency of the ray in the source frame, by nu=E/hbar, E = -p * u
            freq_shift=-transpose(get_source_velocity(Ray[1:4]))*calc_lower_metric(Ray[1:4])*Ray[5:8]
            nu=-colors_freq[ceil(Int,(i-8)/2)]*freq_shift
            #derivative of the optical depth which the ray "will" (hence the - sign) pass through in the "future" (+lambda) to get to the camera
            slope[i]=-calc_spectral_absorbtion_coeficient(Ray[1:8],nu)*freq_shift
        end
    end
    return slope
end


function RK4_Step(Ray,raylength,stepsize,colors_freq)
    #Runge-Kutta Method -- Classic
    k1 = calc_ray_derivative(Ray,raylength,colors_freq)
    k2 = calc_ray_derivative(Ray + k1*stepsize/2, raylength,colors_freq)
    k3 = calc_ray_derivative(Ray + k2*stepsize/2, raylength,colors_freq)
    k4 = calc_ray_derivative(Ray + k3*stepsize, raylength,colors_freq)
    return Ray + stepsize*(k1 + 2*k2 + 2*k3 + k4)/6
end

function RKDP_Step(Ray,slope_last,raylength::Integer,stepsize::Real,colors_freq,abs_tol,rel_tol,prev_rejected::Bool,
                   max_dt::Real)
    #Runge-Kutta Method -- Dormand-Prince method
    #Calculating k's
    k1 = slope_last
    k2 = calc_ray_derivative(Ray + k1*stepsize*DP_Butcher[2,2], raylength,colors_freq)
    k3 = calc_ray_derivative(Ray + stepsize*(k1*DP_Butcher[3,2] + k2*DP_Butcher[3,3]),raylength,colors_freq)
    k4 = calc_ray_derivative(Ray + stepsize*(k1*DP_Butcher[4,2] + k2*DP_Butcher[4,3] + k3*DP_Butcher[4,4]),
                             raylength,colors_freq)
    k5 = calc_ray_derivative(Ray + stepsize*(k1*DP_Butcher[5,2] + k2*DP_Butcher[5,3] + k3*DP_Butcher[5,4] +
        k4*DP_Butcher[5,5]),raylength, colors_freq)
    k6 = calc_ray_derivative(Ray + stepsize*(k1*DP_Butcher[6,2] + k2*DP_Butcher[6,3] + k3*DP_Butcher[6,4] +
        k4*DP_Butcher[6,5] + k5*DP_Butcher[6,6]),raylength, colors_freq)
    
    next_slope=k1*DP_Butcher[7,2] + k3*DP_Butcher[7,4] + k4*DP_Butcher[7,5] + k5*DP_Butcher[7,6] +
        k6*DP_Butcher[7,7]
    
    k7 = calc_ray_derivative(Ray + stepsize*next_slope,raylength, colors_freq)
    
    #Calculating y's
    y = Ray + stepsize*slope_last
    y_hat = Ray + stepsize*(k1*DP_Butcher[9,2] + k3*DP_Butcher[9,4] + k4*DP_Butcher[9,5] + k5*DP_Butcher[9,6] +
        k6*DP_Butcher[9,7] + k7*DP_Butcher[9,8])

    #Estimate error
    delta_y = y-y_hat
    error=0
    for i in 1:raylength
        tol = abs_tol[i]+max(abs(Ray[i]),abs(y[i]))*rel_tol[i]
        error += (delta_y[i]/tol)^2
    end
    error=sqrt(error/raylength)

    """
    if isnan(stepsize)
        println(true)
    end
    """

    #decide next step
    #calc size of next step
    new_stepsize=0.9*stepsize*(1/error)^(1/5)

    if abs(new_stepsize)>max_dt
        new_stepsize=-max_dt
    end
    
    if error == 0 || !isfinite(new_stepsize)
        #error small enough; send updated stats marked as accepted, with same step size (to keep out NaN's)
        return y,next_slope,stepsize,false
    elseif error > 1
        #error too large; send back to manager marked as rejected, with new step size
        if prev_rejected && abs(new_stepsize)>=abs(stepsize)
            #make sure stepsize goes down when the error is too large
            new_stepsize=stepsize/2
        end
        return Ray,slope_last,new_stepsize,true
    else
        #error small enough; send updated stats marked as accepted, with new step size
        #keep stepsize from increasing quickly
        if abs(new_stepsize)>2*abs(stepsize)
            new_stepsize=2*stepsize
        end
        return y,next_slope,new_stepsize,false
    end
end





