"""
v0.3.5
December 5 2025
Author: Levi Malmström
"""

#Spherical Schwarzschild Black Hole: (t,r,θ,ϕ);(γ,v,ω,ψ)
const M = 1
const r_s = 2*M
#r > r_s

function calc_lower_metric(position)
    g=Matrix{Float64}(I,4,4)
    g[1,1] = -(1 - r_s/position[2])
    g[2,2] = inv(1 - r_s/position[2])
    g[3,3]=position[2]^2
    g[4,4]=(position[2]*sin(position[3]))^2
    return g
end

"""
spherical minkowski
function calc_vierbein(position)
    vierbein = Matrix{Float64}(I,4,4)
    vierbein[3,3] = position[2]
    vierbein[4,4] = position[2]*sin(position[3])
    return vierbein
end
"""

function calc_inv_vierbein(position)
    inv_vierbein = Matrix{Float64}(I,4,4)
    inv_vierbein[1,1] = inv(sqrt(1 - r_s/position[2]))
    inv_vierbein[2,2] = sqrt(1 - r_s/position[2])
    inv_vierbein[3,3] = inv(position[2])
    inv_vierbein[4,4] = inv(position[2]*sin(position[3]) + no_div_zero)
    return inv_vierbein
end

function calc_christoffel_udd(position,index::Tuple)
    if index[1]==1
        if (index[2] == 1 && index[3] == 2) || (index[2] == 2 && index[3] == 1)
            return r_s/(2*position[2]*(position[2] - r_s))
        else
            return 0
        end
    elseif index[1]==2
        if index[2]==1 && index[3]==1
            return r_s*(position[2] - r_s)/(2*position[2]^3)
        elseif index[2]==2 && index[3]==2
            return -r_s/(2*position[2]*(position[2] - r_s))
        elseif index[2]==3 && index[3]==3
            return -(position[2]-r_s)
        elseif index[2]==4 && index[3]==4
            return -(position[2]-r_s)*sin(position[3])^2
        else
            return 0
        end
    elseif index[1]==3
        if (index[2]==2 && index[3]==3) || (index[2]==3 && index[3]==2)
            return inv(position[2])
        elseif index[2]==4 && index[3]==4
            return -sin(position[3])*cos(position[3])
        else
            return 0
        end
    elseif index[1]==4
        if (index[2]==2 && index[3]==4) || (index[2]==4 && index[3]==2)
            return inv(position[2])
        elseif (index[2]==3 && index[3]==4) || (index[2]==4 && index[3]==3)
            return cot(position[3])
        else
            return 0
        end
    else
        return 0
    end           
end

function near_singularity(ray,stepsize::Real,abs_tol)
    dθ = stepsize*ray[7]
    θ_new = ray[3] + dθ
    dr = stepsize*ray[6]
    new_r = ray[2]+dr

    #check if near θ = 0
    if abs(θ_new) <= abs_tol[3]
        return true, 2*abs(ray[3])/(abs(ray[7]*9) + no_div_zero)
    #check if near θ = π
    elseif abs(θ_new - π) <= abs_tol[3]
        return true, 2*abs((ray[3] - pi)/(abs(ray[7]*9) + no_div_zero))
"""
    #check if near r = 0
    elseif abs(new_r) <= abs_tol[2]
        return true, 2*(abs_tol[2])/(abs(ray[6]*9) + no_div_zero)
"""
    else
        return false, stepsize
    end
end


function keepinbounds!(ray::Vector)
"""
    if ray[2] <= 0
        ray[2] = -ray[2] + no_div_zero
        ray[6] = -ray[6]
        ray[3] -= π
        ray[7] = -ray[7]
    end
"""
    if ray[2] <= 1
        println("Murphy's Law!")
    end
    if ray[3] < 0
        ray[3] = -ray[3]
        ray[4] -= π
        ray[7] = -ray[7]
    end

    ray[3] = mod(ray[3],2π)
    if ray[3] >= π
        ray[3] = 2π - ray[3]
        ray[4] += π
        ray[7] = -ray[7]
    end
    
    ray[4] = mod(ray[4],2π)
    
    return nothing
end

function is_singularity(position)
    if abs(position[2]) <= 1e-323
        return true
    elseif abs(position[3]) <= 1e-323 || abs(position[3] - π) <= 1e-323
        return true
    else
        return false
    end
end
